package hr.fer.oprpp1.hw02.prob1;

/**
 * Lexer is a class used for tokenizing strings
 * 
 * @author Daniel_Ranogajec
 *
 */
public class Lexer 
{
	private char[] data;
	private Token token; 
	private int currentIndex; 
	private LexerState state;
	
	/**
	 * Creates new Lexer with given string which will be tokenized
	 * @param text that will be tokenized
	 */
	public Lexer(String text) {
		if (text == null)
			throw new NullPointerException();
		
		data = text.toCharArray();
		token = null;
		currentIndex = 0;
		state = LexerState.BASIC;
	}
	
	/**
	 * Method used for setting lexerState (basic or extended)
	 * @param state of a Lexer, can be basic or extended
	 */
	public void setState(LexerState state) {
		if (state == null)
			throw new NullPointerException();
		
		this.state = state;
	}
	
	/**
	 * Method that returns token generated by nextToken()
	 * @return token
	 * @throws LexerException if no tokens were generated by nextToken()
	 */
	public Token getToken() {
		if (token == null)
			throw new LexerException("No token was generated before calling this function!");
		
		return token;
	}
	
	/**
	 * Method that generates and returns next token
	 * @return token
	 * @throws LexerException if there is a problem
	 */
	public Token nextToken() {
		if (token != null && token.getType() == TokenType.EOF)
			throw new LexerException("You have reached EOF, can't generate more tokens.");
		
		if (state == LexerState.BASIC)
			return nextBasicToken();
		
		return nextExtendedToken();
	}
	
	/**
	 * Method that is called by nextToken() if state is basic
	 * @return token
	 * @throws LexerException if illegal escape ('/') is used or if a given String cannot be cast to Long
	 */
	private Token nextBasicToken() {		
		while (checkEOF() && checkWhitespace(data[currentIndex])) 
			currentIndex++;
		if (!(checkEOF()))
			return token = new Token(TokenType.EOF, null);
		
		String s = "";
		if (Character.isLetter(data[currentIndex]) || data[currentIndex] == '\\') {
			if (data[currentIndex] == '\\') {
				currentIndex++;
				if (!(checkEOF()) || Character.isLetter(data[currentIndex]))
					throw new LexerException("Illegal escape!");
			}
			s += data[currentIndex++];
			while (checkEOF() && (Character.isLetter(data[currentIndex]) || data[currentIndex] == '\\')) {
				if (data[currentIndex] == '\\') {
					currentIndex++;
					if (!(checkEOF()) || Character.isLetter(data[currentIndex]))
						throw new LexerException("Illegal escape!");
				}
				s += data[currentIndex++];
			}
			token = new Token(TokenType.WORD, s);
			
		} else if (Character.isDigit(data[currentIndex])) {
			s += data[currentIndex++];
			while (checkEOF() && Character.isDigit(data[currentIndex])) 	
				s += data[currentIndex++];
			try {
				token = new Token(TokenType.NUMBER, Long.parseLong(s));
			} catch (NumberFormatException ex) {
				throw new LexerException("Not a number!");
			}
			
		} else {
			token = new Token(TokenType.SYMBOL, data[currentIndex++]);
		}
		
		return token;
	}
	
	/**
	 * Method that is called by nextToken() if state is extended
	 * @return token
	 */
	private Token nextExtendedToken() {
		while (checkEOF() && checkWhitespace(data[currentIndex]))
			currentIndex++;
		if (!(checkEOF()))
			return token = new Token(TokenType.EOF, null);
		
		if (data[currentIndex] == '#') {
			return token = new Token(TokenType.SYMBOL, data[currentIndex++]);
		}
		
		String s = "";
		while (checkEOF() && data[currentIndex] != '#' && !(checkWhitespace(data[currentIndex]))) {
			s += data[currentIndex++];
		}
		
		return new Token(TokenType.WORD, s);
	}

	/**
	 * Method that checks if character is a whitespace
	 * @param c character that if being tested
	 * @return true if given character is a whitespace
	 */
	private boolean checkWhitespace(char c) {
		if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
			return true;
		
		return false;
	}
	
	/**
	 * Method that checks if EOF is reached
	 * @return true if EOF is not reached
	 */
	private boolean checkEOF() {
		return (currentIndex < data.length);
	}

}
