package hr.fer.oprpp1.custom.scripting.lexer;

/**
 * SmartScriptLexer is a class used for tokenizing strings
 * 
 * @author Daniel_Ranogajec
 *
 */
public class SmartScriptLexer {
	private char[] data;
	private SmartScriptToken token; 
	private int currentIndex;
	private SmartScriptLexerState state;
	
	
	/**
	 * Creates new SmartScriptLexer with given string which will be tokenized
	 * @param text that will be tokenized
	 * @throws NullPointerException if given text is null
	 */
	public SmartScriptLexer(String text) {
		if (text == null)
			throw new NullPointerException("Given text shouldn't be null!");
		
		data = text.toCharArray();
		token = null;
		currentIndex = 0;
		state = SmartScriptLexerState.TEXT;
	}
	
	/**
	 * Method that returns token generated by nextToken()
	 * @return token 
	 * @throws SmartScriptLexerException if no tokens were generated by nextToken()
	 */
	public SmartScriptToken getToken() {
		if (token == null)
			throw new SmartScriptLexerException("No token was generated before calling this function!");
		
		return token;
	}
	
	/**
	 * Method that generates and returns next token
	 * @return token
	 * @throws SmartScriptLexerException if there is a problem
	 */
	public SmartScriptToken nextToken() {
		if (token != null && token.getType() == SmartScriptTokenType.EOF)
			throw new SmartScriptLexerException("You have reached EOF, can't generate more tokens.");
		
		skipWhitespace();
		if (!(checkEOF()))
			return token = new SmartScriptToken(SmartScriptTokenType.EOF, null);
		
		if (state == SmartScriptLexerState.TEXT) {
			token = nextTextToken();
		} else if (state == SmartScriptLexerState.TAG) {
			token = nextTagToken();
		} else if (state == SmartScriptLexerState.BODY) {
			token = nextBodyToken();
		} else {
			throw new SmartScriptLexerException();
		}

		return token;
	}

	/**
	 * Method that generates token for content inside of tag body
	 * @return token
	 * @throws SmartScriptLexerException if the token body couldn't be matched with its type enumeration
	 */
	private SmartScriptToken nextBodyToken() {
		if (Character.isLetter(data[currentIndex])) {
			return new SmartScriptToken(SmartScriptTokenType.VARIABLE, getVariable());
			
		} else if (Character.isDigit(data[currentIndex]) || 
				(data[currentIndex] == '-' && Character.isDigit(data[currentIndex + 1]))) {
			double d = getConstant();
			if (d % 1 == 0) 
				return new SmartScriptToken(SmartScriptTokenType.INTEGER, (int) d);
			else 
				return new SmartScriptToken(SmartScriptTokenType.DOUBLE, d);
			
		} else if (data[currentIndex] == '@') {
			return new SmartScriptToken(SmartScriptTokenType.FUNCTION, getFunction());
			
		} else if (data[currentIndex] == '"') {	
			return new SmartScriptToken(SmartScriptTokenType.STRING, getString());
			
		} else if (data[currentIndex] == '+' || data[currentIndex] == '-' || data[currentIndex] == '*' 
				|| data[currentIndex] == '/' || data[currentIndex] == '^') {
			return new SmartScriptToken(SmartScriptTokenType.OPERATOR, data[currentIndex++]);

		} else if (data[currentIndex] == '$' && data[currentIndex + 1] == '}') {
			state = SmartScriptLexerState.TEXT;
			currentIndex += 2;
			return new SmartScriptToken(SmartScriptTokenType.ENDTAG, null);
		}
		
		throw new SmartScriptLexerException("No such token in its type enumeration!");
	}
	
	/**
	 * Method that generates token for tags 
	 * @return token
	 * @throws SmartScriptLexerException if the token body couldn't be matched with its type enumeration
	 */
	private SmartScriptToken nextTagToken() {
		if (Character.toLowerCase(data[currentIndex]) == 'f' && Character.toLowerCase(data[currentIndex + 1]) == 'o'
				&& Character.toLowerCase(data[currentIndex + 2]) == 'r') {
			currentIndex += 3;
			state = SmartScriptLexerState.BODY;
			return new SmartScriptToken(SmartScriptTokenType.TAG, "FOR");
		} else if (Character.toLowerCase(data[currentIndex]) == 'e' && Character.toLowerCase(data[currentIndex + 1]) == 'n'
				&& Character.toLowerCase(data[currentIndex + 2]) == 'd') {
			currentIndex += 3;
			while (data[currentIndex] != '$' && data[currentIndex + 1] != '}')
				currentIndex++;
			currentIndex += 2;
			state = SmartScriptLexerState.TEXT;
			return new SmartScriptToken(SmartScriptTokenType.TAG, "END");
		} else if (data[currentIndex] == '=') {
			currentIndex++;
			state = SmartScriptLexerState.BODY;
			
			return new SmartScriptToken(SmartScriptTokenType.TAG, "=");
		} 
		
		throw new SmartScriptLexerException("No such token in its type enumeration!");
	}

	/**
	 * Method that generates token for text elements 
	 * @return token
	 * @throws SmartScriptLexerException if illegal escape ('/') is used
	 */
	private SmartScriptToken nextTextToken() {
		String s = "";
		while (checkEOF()) {
			if (data[currentIndex] == '{') {
				currentIndex++;
				if (checkEOF() && data[currentIndex] == '$') {
					currentIndex++;
					break;
				} 
				s += "{";
			}
			if (data[currentIndex] == '\\') {
				currentIndex++;
				if (!(checkEOF() && (data[currentIndex] == '\\' || data[currentIndex] == '{')))
					throw new SmartScriptLexerException("Illegal escape was used!");
			}
			
			s += data[currentIndex++];
		}

		if (checkEOF()) {
			state = SmartScriptLexerState.TAG;
		}
		
		return new SmartScriptToken(SmartScriptTokenType.TEXT, s);
	}
	
	/**
	 * Method that generates string to store in a token
	 * @return string
	 * @throws SmartScriptLexerException if illegal escape ('/') is used or if reached EOF before closing the string
	 */
	private String getString() {
		String s = "";
		currentIndex++;
		while (checkEOF()) {
			if (data[currentIndex] == '"' && data[currentIndex - 1] != '\\') {
				currentIndex++;
				break;
			}
			if (data[currentIndex] != '\\') {
				s += data[currentIndex++];
			} else {
				currentIndex++;
				if (!(checkEOF())) {
					throw new SmartScriptLexerException("Reached EOF without closing the string!");
				} else if (data[currentIndex] == '\\' || data[currentIndex] == '"') {
					s += data[currentIndex++];
				}  else if (data[currentIndex] == 'n' || data[currentIndex] == 't' 
						|| data[currentIndex] == 'r' || data[currentIndex] == ' ') {
					s += "\\" + data[currentIndex++];
				}
				else { 
					throw new SmartScriptLexerException("Illegal escape was used!");
				}

			}
		}
		
		return s;
	}

	/**
	 * Method that generates function (String) to store in a token
	 * @return function (String)
	 * @throws SmartScriptLexerException if first character of function isn't a letter
	 */
	private String getFunction() {
		if (!(Character.isLetter(data[++currentIndex])))
			throw new SmartScriptLexerException("Function must begin with a letter!");
		
		String s = Character.toString(data[currentIndex++]);
		while (checkEOF() && (Character.isLetter(data[currentIndex]) ||
				Character.isDigit(data[currentIndex]) || data[currentIndex] == '_')) {
			s += data[currentIndex++];
		}
		return s;
	}
	
	/** 
	 * Method that generates constant(double) to store in a token
	 * @return constant (Double)
	 * @throws SmartScriptLexerException if given String cannot be cast to a Double
	 */
	private double getConstant() {
		String s = Character.toString(data[currentIndex++]);
		while (checkEOF() && (Character.isDigit(data[currentIndex]) || data[currentIndex] == '.')) {
			s += data[currentIndex++];
		} try {
			return Double.parseDouble(s);
		} catch (NumberFormatException ex) {
			throw new SmartScriptLexerException("Not a number!");
		}
	}

	/** 
	 * Method that generates variable (String) to store in a token
	 * @return variable (String)
	 */
	private String getVariable() {
		String s = Character.toString(data[currentIndex++]);
		while (checkEOF() && (Character.isLetter(data[currentIndex]) || 
						Character.isDigit(data[currentIndex]) || data[currentIndex] == '_')) {
			s += data[currentIndex++];
		}
		return s;
	}
	
	/**
	 * Method used for skipping whitespace
	 */
	private void skipWhitespace() {
		while (checkEOF() && (data[currentIndex] == ' ' || data[currentIndex] == '\r' 
				|| data[currentIndex] == '\n' || data[currentIndex] == '\t')) 
			currentIndex++;
	}
	
	/**
	 * Method used for checking if string has reached its end
	 * @return true if string hasn't reached its end, false otherwise
	 */
	private boolean checkEOF() {
		return (currentIndex < data.length);
	}

}
